<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>For developers · OffsetArrays</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">OffsetArrays</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">OffsetArrays.jl</a></li><li class="is-active"><a class="tocitem" href="">For developers</a><ul class="internal"><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#The-axes-of-OffsetArrays"><span>The axes of OffsetArrays</span></a></li><li><a class="tocitem" href="#Wrapping-other-offset-array-types"><span>Wrapping other offset array types</span></a></li><li><a class="tocitem" href="#Caveats"><span>Caveats</span></a></li><li><a class="tocitem" href="#Using-custom-axis-types"><span>Using custom axis types</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">For developers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">For developers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/master/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="For-developers"><a class="docs-heading-anchor" href="#For-developers">For developers</a><a id="For-developers-1"></a><a class="docs-heading-anchor-permalink" href="#For-developers" title="Permalink"></a></h1><p>Writing code that supports OffsetArrays is generally fairly straightforward. The majority of cases can be handled with these tips:</p><ul><li>replace many uses of <code>size</code> with <code>axes</code></li><li>replace <code>1:length(A)</code> with <code>eachindex(A)</code>, or if you need an integer index with <code>LinearIndices(A)</code></li><li>replace explicit allocations like <code>Array{Int}(undef, size(B))</code> with <code>similar(Array{Int}, axes(B))</code></li></ul><p>More information can be found in <a href="https://docs.julialang.org/en/v1/devdocs/offset-arrays/">Julia's developer documentation</a>. The most subtle issues tend to arise around the axes, and further detail specific to OffsetArrays.jl follows below.</p><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>How does OffsetArrays work? The fundamental principle is very simple: an <code>OffsetArray</code> is just a wrapper around a "parent" array, together with an index offset:</p><pre><code class="language-julia-repl">julia&gt; oa = OffsetArray([1 2; 3 4], 0:1, 5:6)
2×2 OffsetArray(::Matrix{Int64}, 0:1, 5:6) with eltype Int64 with indices 0:1×5:6:
 1  2
 3  4

julia&gt; parent(oa)
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; oa.offsets
(-1, 4)</code></pre><p>So <code>parent(oa)</code> is the original array we constructed it with, and <code>oa.offsets</code> is a tuple, each entry encoding the index-shift to be applied along the corresponding axis. When you index <code>oa[i,j]</code>, it "translates" the <code>i,j</code> indexes back to the parent array's indexes and then returns the value in the parent.</p><h2 id="The-axes-of-OffsetArrays"><a class="docs-heading-anchor" href="#The-axes-of-OffsetArrays">The axes of OffsetArrays</a><a id="The-axes-of-OffsetArrays-1"></a><a class="docs-heading-anchor-permalink" href="#The-axes-of-OffsetArrays" title="Permalink"></a></h2><p>The internal of offset computing is achieved by <a href="../reference/#OffsetArrays.IdOffsetRange"><code>IdOffsetRange</code></a> type:</p><pre><code class="language-julia-repl">julia&gt; ax = axes(oa, 2)
OffsetArrays.IdOffsetRange(values=5:6, indices=5:6)</code></pre><p>This has a similar design to <code>Base.IdentityUnitRange</code> that <code>ax[x] == x</code> always holds.</p><pre><code class="language-julia-repl">julia&gt; ax[5]
5
julia&gt; ax[1]
ERROR: BoundsError: attempt to access 2-element Base.OneTo{Int64} at index [-3]
[...]</code></pre><p>This property makes sure that they tend to be their own axes:</p><pre><code class="language-julia-repl">julia&gt; axes(ax)
(OffsetArrays.IdOffsetRange(values=5:6, indices=5:6),)

julia&gt; axes(ax[ax])
(OffsetArrays.IdOffsetRange(values=5:6, indices=5:6),)</code></pre><p>This example of indexing is <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a>. This is a useful characteristic for ensuring the "fundamental axiom" of generalized indexing, that <code>a[ax][i] == a[ax[i]]</code>:</p><pre><code class="language-julia-repl">julia&gt; oa2 = OffsetArray([5, 10, 15, 20], 0:3)
4-element OffsetArray(::Vector{Int64}, 0:3) with eltype Int64 with indices 0:3:
  5
 10
 15
 20

julia&gt; ax2 = axes(oa2, 1)
OffsetArrays.IdOffsetRange(values=0:3, indices=0:3)

julia&gt; oa2[2]
15

julia&gt; oa2[ax2][2]
15

julia&gt; oa2[ax2[2]]
15</code></pre><p><code>IdOffsetRange</code>s apply the offset both to the values and the indices of the range, and otherwise preserve the parent range.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>There are circumstances where constructing a specific type of <code>IdOffsetRange</code> cannot be supported without changing the axes of the range (see <a href="../reference/#OffsetArrays.IdOffsetRange"><code>OffsetArrays.IdOffsetRange</code></a>.) In the future, this package will distinguish between <em>construction</em>  and <em>conversion</em>:</p><ul><li>construction (aka, <em>coercion</em>) will always succeed, even if it has to change the axes of the result (Examples: <code>RangeType(rng)</code>, <code>typeof(rng1)(rng2)</code>)</li><li>conversion will succeed only if it can preserve both the values and the axes (Examples: <code>convert(RangeType, rng)</code>, <code>oftype(rng1, rng2)</code>)</li></ul><p>While these behave equivalently now (conversion currently performs coercion), developers are encouraged to "future-proof" their code by choosing the behavior appropriate for each usage.</p></div></div><h2 id="Wrapping-other-offset-array-types"><a class="docs-heading-anchor" href="#Wrapping-other-offset-array-types">Wrapping other offset array types</a><a id="Wrapping-other-offset-array-types-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapping-other-offset-array-types" title="Permalink"></a></h2><p>An <code>OffsetArray</code> may wrap any subtype of <code>AbstractArray</code>, including ones that do not use <code>1</code>-based indexing. Such arrays however need to satisfy the fundamental axiom of idempotent indexing for things to work correctly. In other words, an axis of an offset array needs to have the same values as its own axis. This property is built into <code>OffsetArray</code>s if the parent uses 1-based indexing, but it's up to the user to ensure the correctness in case a type is to be wrapped that uses offset indices.</p><p>We demonstrate this through an example by creating a custom 0-based range type that we wrap in an <code>OffsetArray</code>:</p><pre><code class="language-julia-repl">julia&gt; struct ZeroBasedRange{T,A&lt;:AbstractRange{T}} &lt;: AbstractRange{T}
           a :: A
           function ZeroBasedRange(a::AbstractRange{T}) where {T}
               @assert !Base.has_offset_axes(a)
               new{T, typeof(a)}(a)
           end
       end;

julia&gt; Base.parent(A::ZeroBasedRange) = A.a;

julia&gt; Base.first(A::ZeroBasedRange) = first(A.a);

julia&gt; Base.length(A::ZeroBasedRange) = length(A.a);

julia&gt; Base.last(A::ZeroBasedRange) = last(A.a);

julia&gt; Base.size(A::ZeroBasedRange) = size(A.a);

julia&gt; Base.axes(A::ZeroBasedRange) = map(x -&gt; 0:x-1, size(A.a));

julia&gt; Base.getindex(A::ZeroBasedRange, i::Int) = A.a[i + 1];

julia&gt; Base.step(A::ZeroBasedRange) = step(A.a);

julia&gt; function Base.show(io::IO, A::ZeroBasedRange)
           show(io, A.a)
           print(io, " with indices $(axes(A,1))")
       end;</code></pre><p>This definition of a <code>ZeroBasedRange</code> appears to have the correct indices, for example:</p><pre><code class="language-julia-repl">julia&gt; z = ZeroBasedRange(1:4)
1:4 with indices 0:3

julia&gt; z[0]
1

julia&gt; z[3]
4</code></pre><p>However this does not use idempotent indexing, as the axis of a <code>ZeroBasedRange</code> is not its own axis.</p><pre><code class="language-julia-repl">julia&gt; axes(z, 1)
0:3

julia&gt; axes(axes(z, 1), 1)
Base.OneTo(4)</code></pre><p>This will lead to complications in certain functions –- for example <code>LinearIndices</code> –- that tend to implictly assume idempotent indexing. In this case the <code>LinearIndices</code> of <code>z</code> will not match its axis.</p><pre><code class="language-julia-repl">julia&gt; LinearIndices(z)
4-element LinearIndices{1, Tuple{UnitRange{Int64}}}:
 1
 2
 3
 4</code></pre><p>Wrapping such a type in an <code>OffsetArray</code> might lead to unexpected bugs.</p><pre><code class="language-julia-repl">julia&gt; zo = OffsetArray(z, 1);

julia&gt; axes(zo, 1)
OffsetArrays.IdOffsetRange(values=1:4, indices=2:5)

julia&gt; Array(zo)
ERROR: BoundsError: attempt to access 4-element UnitRange{Int64} at index [5]
[...]</code></pre><p>The <code>Array</code> conversion errors despite <code>zo</code> having 1-based indices. The function <code>axes(zo, 1)</code> hints at the underlying problem –- the values and the indices of the axis are different. We may check that the axis of <code>zo</code> is not its own axis:</p><pre><code class="language-julia-repl">julia&gt; axes(zo, 1)
OffsetArrays.IdOffsetRange(values=1:4, indices=2:5)

julia&gt; axes(axes(zo, 1), 1)
OffsetArrays.IdOffsetRange(values=2:5, indices=2:5)</code></pre><p>In this case the bug may be fixed by defining the <code>axes</code> of a <code>ZeroBasedRange</code> to be idempotent, for example using the <code>OffsetArrays.IdentityUnitRange</code> wrapper:</p><pre><code class="language-julia-repl">julia&gt; Base.axes(A::ZeroBasedRange) = map(x -&gt; OffsetArrays.IdentityUnitRange(0:x-1), size(A.a))

julia&gt; axes(zo, 1)
OffsetArrays.IdOffsetRange(values=1:4, indices=1:4)</code></pre><p>With this new definition, the values and indices of the axis are identical, which makes indexing idempotent. The conversion to an <code>Array</code> works as expected now:</p><pre><code class="language-julia-repl">julia&gt; Array(zo)
4-element Vector{Int64}:
 1
 2
 3
 4</code></pre><h2 id="Caveats"><a class="docs-heading-anchor" href="#Caveats">Caveats</a><a id="Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Caveats" title="Permalink"></a></h2><p>Because <code>IdOffsetRange</code> behaves quite differently to the normal <code>UnitRange</code> type, there are some cases that you should be aware of, especially when you are working with multi-dimensional arrays.</p><p>One such cases is <code>getindex</code>:</p><pre><code class="language-julia-repl">julia&gt; Ao = zeros(-3:3, -3:3); Ao[:] .= 1:49;

julia&gt; Ao[-3:0, :] |&gt; axes # the first dimension does not preserve offsets
(OffsetArrays.IdOffsetRange(values=1:4, indices=1:4), OffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3))

julia&gt; Ao[-3:0, -3:3] |&gt; axes # neither dimensions preserve offsets
(Base.OneTo(4), Base.OneTo(7))

julia&gt; Ao[axes(Ao)...] |&gt; axes # offsets are preserved
(OffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3), OffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3))

julia&gt; Ao[:] |&gt; axes # This is linear indexing
(Base.OneTo(49),)</code></pre><p>Note that if you pass a <code>UnitRange</code>, the offsets in corresponding dimension will not be preserved. This might look weird at first, but since it follows the <code>a[ax][i] == a[ax[i]]</code> rule, it is not a bug.</p><pre><code class="language-julia-repl">julia&gt; I = -3:0; # UnitRange always starts at index 1

julia&gt; Ao[I, 0][1] == Ao[I[1], 0]
true

julia&gt; ax = axes(Ao, 1) # ax starts at index -3
OffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3)

julia&gt; Ao[ax, 0][1] == Ao[ax[1], 0]
true</code></pre><h2 id="Using-custom-axis-types"><a class="docs-heading-anchor" href="#Using-custom-axis-types">Using custom axis types</a><a id="Using-custom-axis-types-1"></a><a class="docs-heading-anchor-permalink" href="#Using-custom-axis-types" title="Permalink"></a></h2><p>While a wide variety of <code>AbstractUnitRange</code>s provided by <code>Base</code> may be used as indices to construct an <code>OffsetArray</code>, at times it might be convenient to define custom types. The <code>OffsetArray</code> constructor accepts any type that may be converted to an <code>AbstractUnitRange</code>. This proceeds through a two-step process. Let's assume that the constructor called is <code>OffsetArray(A, indstup)</code>, where <code>indstup</code> is a <code>Tuple</code> of indices.</p><ol><li><p>At the first step, the constructor calls <code>to_indices(A, axes(A), indstup)</code> to lower <code>indstup</code> to a <code>Tuple</code> of <code>AbstractUnitRange</code>s. This step converts –- among other things –- <code>Colon</code>s to axis ranges. Custom types may extend <code>Base.to_indices(A, axes(A), indstup)</code> with the desired conversion of <code>indstup</code> to <code>Tuple{Vararg{AbstractUnitRange{Int}}}</code> if this is feasible.</p></li><li><p>At the second step, the result obtained from the previous step treated again to convert it to a <code>Tuple</code> of <code>AbstractUnitRange</code>s to handle cases where the first step doesn't achieve this. An additional customization option may be specified at this stage: a type may be converted either to a single <code>AbstractUnitRange{Int}</code>, or to a <code>Tuple</code> of them. A type might specify which of these two behaviours is desired by extending <a href="../reference/#OffsetArrays.AxisConversionStyle"><code>OffsetArrays.AxisConversionStyle</code></a>. An example of a type that is acted upon at this stage is <code>CartesianIndices</code>, which is converted to a <code>Tuple</code> of <code>AbstractUnitRange</code>s.</p></li></ol><p>For example, here are a couple of custom type that facilitate zero-based indexing:</p><pre><code class="language-julia-repl">julia&gt; struct ZeroBasedIndexing end

julia&gt; Base.to_indices(A, inds, ::Tuple{ZeroBasedIndexing}) = map(x -&gt; 0:length(x)-1, inds)

julia&gt; a = zeros(3, 3);

julia&gt; oa = OffsetArray(a, ZeroBasedIndexing());

julia&gt; axes(oa)
(OffsetArrays.IdOffsetRange(values=0:2, indices=0:2), OffsetArrays.IdOffsetRange(values=0:2, indices=0:2))</code></pre><p>In this example we had to define the action of <code>to_indices</code> as the type <code>ZeroBasedIndexing</code> did not have a familiar hierarchy. Things are even simpler if we subtype <code>AbstractUnitRange</code>, in which case we need to define <code>first</code> and <code>length</code> for the custom range to be able to use it as an axis:</p><pre><code class="language-julia-repl">julia&gt; struct ZeroTo &lt;: AbstractUnitRange{Int}
       n :: Int
       ZeroTo(n) = new(n &lt; 0 ? -1 : n)
       end

julia&gt; Base.first(::ZeroTo) = 0

julia&gt; Base.length(r::ZeroTo) = r.n + 1

julia&gt; oa = OffsetArray(zeros(2,2), ZeroTo(1), ZeroTo(1));

julia&gt; axes(oa)
(OffsetArrays.IdOffsetRange(values=0:1, indices=0:1), OffsetArrays.IdOffsetRange(values=0:1, indices=0:1))</code></pre><p>Note that zero-based indexing may also be achieved using the pre-defined type <a href="../reference/#OffsetArrays.Origin"><code>OffsetArrays.Origin</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« OffsetArrays.jl</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 15 July 2021 17:18">Thursday 15 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>