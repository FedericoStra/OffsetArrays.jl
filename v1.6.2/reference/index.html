<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Reference · OffsetArrays</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">OffsetArrays</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">OffsetArrays.jl</a></li><li><a class="tocitem" href="../internals/">For developers</a></li><li class="is-active"><a class="tocitem" href="">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" href="#OffsetArrays.OffsetArray" id="OffsetArrays.OffsetArray"><code>OffsetArrays.OffsetArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OffsetArray(A, indices...)</code></pre><p>Return an <code>AbstractArray</code> that shares element type and size with the first argument but uses the supplied <code>indices</code> to infer its axes. If all the indices are <code>AbstractUnitRange</code>s then these are directly used as the axis span along each dimension. Refer to the examples below for other permissible types.</p><p>Alternatively it's possible to specify the coordinates of one corner of the array and have the axes be computed automatically from the size of <code>A</code>. This constructor makes it convenient to shift to an arbitrary starting index along each axis, for example to a zero-based indexing scheme followed by arrays in languages such as C and Python. See <a href="#OffsetArrays.Origin"><code>Origin</code></a> and the examples below for this usage.</p><p><strong>Example: offsets</strong></p><p>There are two types of <code>indices</code>: integers and ranges-like types.</p><p>Integers are recognized as offsets, where <code>0</code> means no offsets are applied:</p><pre><code class="language-julia-repl">julia&gt; A = OffsetArray(reshape(1:6, 2, 3), -1, -2)
2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:
 1  3  5
 2  4  6

julia&gt; A[0, 1]
5</code></pre><p>Examples of range-like types are: <code>UnitRange</code> (e.g, <code>-1:2</code>), <code>CartesianIndices</code>, and <code>Colon()</code> (or concisely <code>:</code>). A <code>UnitRange</code> specifies the axis span along one particular dimension, <code>CartesianIndices</code> specify the axis spans along multiple dimensions, and a <code>Colon</code> is a placeholder that specifies that the <code>OffsetArray</code> shares its axis with its parent along that dimension.</p><pre><code class="language-julia-repl">julia&gt; OffsetArray(reshape(1:6, 2, 3), 0:1, -1:1)
2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:
 1  3  5
 2  4  6

julia&gt; OffsetArray(reshape(1:6, 2, 3), :, -1:1) # : as a placeholder to indicate that no offset is to be applied to the first dimension
2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 1:2, -1:1) with eltype Int64 with indices 1:2×-1:1:
 1  3  5
 2  4  6</code></pre><p>Use <code>CartesianIndices</code> to specify the coordinates of two diagonally opposite corners:</p><pre><code class="language-julia-repl">julia&gt; OffsetArray(reshape(1:6, 2, 3), CartesianIndex(0, -1):CartesianIndex(1, 1))
2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:
 1  3  5
 2  4  6</code></pre><p>Integers and range-like types may not be combined in the same call:</p><pre><code class="language-julia">julia&gt; OffsetArray(reshape(1:6, 2, 3), 0, -1:1)
ERROR: [...]</code></pre><p><strong>Example: origin</strong></p><p><a href="#OffsetArrays.Origin"><code>OffsetArrays.Origin</code></a> may be used to specify the origin of the OffsetArray. The term origin here refers to the corner with the lowest values of coordinates, such as the left edge for an <code>AbstractVector</code>, the bottom left corner for an <code>AbstractMatrix</code> and so on. The coordinates of the origin sets the starting index of the array along each dimension.</p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4];

julia&gt; OffsetArray(a, OffsetArrays.Origin(0, 1))
2×2 OffsetArray(::Array{Int64,2}, 0:1, 1:2) with eltype Int64 with indices 0:1×1:2:
 1  2
 3  4

julia&gt; OffsetArray(a, OffsetArrays.Origin(0)) # set the origin to zero along each dimension
2×2 OffsetArray(::Array{Int64,2}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/fe95c006c6052c083de3b01b70f1b049e5e09eed/src/OffsetArrays.jl#L23-L109" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#OffsetArrays.OffsetVector" id="OffsetArrays.OffsetVector"><code>OffsetArrays.OffsetVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OffsetVector(v, index)</code></pre><p>Type alias and convenience constructor for one-dimensional <a href="#OffsetArrays.OffsetArray"><code>OffsetArray</code></a>s.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/fe95c006c6052c083de3b01b70f1b049e5e09eed/src/OffsetArrays.jl#L124-L128" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#OffsetArrays.OffsetMatrix" id="OffsetArrays.OffsetMatrix"><code>OffsetArrays.OffsetMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OffsetMatrix(A, index1, index2)</code></pre><p>Type alias and convenience constructor for two-dimensional <a href="#OffsetArrays.OffsetArray"><code>OffsetArray</code></a>s.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/fe95c006c6052c083de3b01b70f1b049e5e09eed/src/OffsetArrays.jl#L131-L135" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#OffsetArrays.Origin" id="OffsetArrays.Origin"><code>OffsetArrays.Origin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Origin(indices...)
Origin(origin::Tuple)
Origin(origin::CartesianIndex)</code></pre><p>A helper type to construct OffsetArray with given origin.</p><p>The <code>origin</code> of an array is defined as the index of its first element, i.e., <code>first.(axes(A))</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4];

julia&gt; OffsetArray(a, OffsetArrays.Origin(0, 1))
2×2 OffsetArray(::Array{Int64,2}, 0:1, 1:2) with eltype Int64 with indices 0:1×1:2:
 1  2
 3  4

julia&gt; OffsetArray(a, OffsetArrays.Origin(0)) # short notation for `Origin(0, 0)`
2×2 OffsetArray(::Array{Int64,2}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/fe95c006c6052c083de3b01b70f1b049e5e09eed/src/origin.jl#L1-L25" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#OffsetArrays.IdOffsetRange" id="OffsetArrays.IdOffsetRange"><code>OffsetArrays.IdOffsetRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ro = IdOffsetRange(r::AbstractUnitRange, offset=0)</code></pre><p>Construct an "identity offset range". Numerically, <code>collect(ro) == collect(r) .+ offset</code>, with the additional property that <code>axes(ro, 1) = axes(r, 1) .+ offset</code>. When <code>r</code> starts at 1, then <code>ro[i] == i</code> and even <code>ro[ro] == ro</code>, i.e., it's the "identity," which is the origin of the "Id" in <code>IdOffsetRange</code>.</p><p><strong>Examples</strong></p><p>The most common case is shifting a range that starts at 1 (either <code>1:n</code> or <code>Base.OneTo(n)</code>):</p><pre><code class="language-julia-repl">julia&gt; ro = OffsetArrays.IdOffsetRange(1:3, -2)
OffsetArrays.IdOffsetRange(-1:1)

julia&gt; axes(ro, 1)
OffsetArrays.IdOffsetRange(-1:1)

julia&gt; ro[-1]
-1

julia&gt; ro[3]
ERROR: BoundsError: attempt to access 3-element UnitRange{Int64} at index [5]</code></pre><p>If the range doesn't start at 1, the values may be different from the indices:</p><pre><code class="language-julia-repl">julia&gt; ro = OffsetArrays.IdOffsetRange(11:13, -2)
OffsetArrays.IdOffsetRange(9:11)

julia&gt; axes(ro, 1)     # 11:13 is indexed by 1:3, and the offset is also applied to the axes
OffsetArrays.IdOffsetRange(-1:1)

julia&gt; ro[-1]
9

julia&gt; ro[3]
ERROR: BoundsError: attempt to access 3-element UnitRange{Int64} at index [5]</code></pre><p><strong>Extended help</strong></p><p>Construction/coercion preserves the (shifted) values of the input range, but may modify the indexes if required by the specified types. For example,</p><pre><code class="language-none">r = OffsetArrays.IdOffsetRange{Int,UnitRange{Int}}(3:4)</code></pre><p>has <code>r[1] == 3</code> and <code>r[2] == 4</code>, whereas</p><pre><code class="language-none">r = OffsetArrays.IdOffsetRange{Int,Base.OneTo{Int}}(3:4)</code></pre><p>has <code>r[3] == 3</code> and <code>r[4] == 4</code>, and <code>r[1]</code> would throw a <code>BoundsError</code>. In this latter case, a shift in the axes was needed because <code>Base.OneTo</code> ranges must start with value 1.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In the future, <em>conversion</em> will preserve both the values and the indices, throwing an error when this is not achievable. For instance,</p><pre><code class="language-none">r = convert(OffsetArrays.IdOffsetRange{Int,UnitRange{Int}}, 3:4)</code></pre><p>has <code>r[1] == 3</code> and <code>r[2] == 4</code> and would satisfy <code>r == 3:4</code>, whereas</p><pre><code class="language-julia">julia&gt; convert(OffsetArrays.IdOffsetRange{Int,Base.OneTo{Int}}, 3:4)    # future behavior, not present behavior
ERROR: ArgumentError: first element must be 1, got 3</code></pre><p>where the error will arise because the result could not have the same axes as the input.</p><p>An important corollary is that <code>typeof(r1)(r2)</code> and <code>oftype(r1, r2)</code> will behave differently: the first coerces <code>r2</code> to be of the type of <code>r1</code>, whereas the second converts. Developers are urged to future-proof their code by choosing the behavior appropriate for each usage.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/fe95c006c6052c083de3b01b70f1b049e5e09eed/src/axes.jl#L1-L75" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#OffsetArrays.no_offset_view" id="OffsetArrays.no_offset_view"><code>OffsetArrays.no_offset_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">no_offset_view(A)</code></pre><p>Return an <code>AbstractArray</code> that shares structure and underlying data with the argument, but uses 1-based indexing. May just return the argument when applicable. Not exported.</p><p>The default implementation uses <code>OffsetArrays</code>, but other types should use something more specific to remove a level of indirection when applicable.</p><pre><code class="language-julia-repl">julia&gt; A = [1 3 5; 2 4 6];

julia&gt; O = OffsetArray(A, 0:1, -1:1)
2×3 OffsetArray(::Array{Int64,2}, 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:
 1  3  5
 2  4  6

julia&gt; OffsetArrays.no_offset_view(O)[1,1] = -9
-9

julia&gt; A
2×3 Array{Int64,2}:
 -9  3  5
  2  4  6</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/fe95c006c6052c083de3b01b70f1b049e5e09eed/src/OffsetArrays.jl#L427-L453" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#OffsetArrays.AxisConversionStyle" id="OffsetArrays.AxisConversionStyle"><code>OffsetArrays.AxisConversionStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OffsetArrays.AxisConversionStyle(typeof(indices))</code></pre><p><code>AxisConversionStyle</code> declares if <code>indices</code> should be converted to a single <code>AbstractUnitRange{Int}</code>  or to a <code>Tuple{Vararg{AbstractUnitRange{Int}}}</code> while flattening custom types into indices.  This method is called after <code>to_indices(A::Array, axes(A), indices)</code> to provide  further information in case <code>to_indices</code> does not return a <code>Tuple</code> of <code>AbstractUnitRange{Int}</code>.</p><p>Custom index types should extend <code>AxisConversionStyle</code> and return either <code>OffsetArray.SingleRange()</code>,  which is the default, or <code>OffsetArray.TupleOfRanges()</code>. In the former case, the type <code>T</code> should  define <code>Base.convert(::Type{AbstractUnitRange{Int}}, ::T)</code>, whereas in the latter it should define  <code>Base.convert(::Type{Tuple{Vararg{AbstractUnitRange{Int}}}}, ::T)</code>. </p><p>An example of the latter is <code>CartesianIndices</code>, which is converted to a <code>Tuple</code> of  <code>AbstractUnitRange{Int}</code> while flattening the indices.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; struct NTupleOfUnitRanges{N}
           x ::NTuple{N, UnitRange{Int}}
       end

julia&gt; Base.to_indices(A, inds, t::Tuple{NTupleOfUnitRanges{N}}) where {N} = t;

julia&gt; OffsetArrays.AxisConversionStyle(::Type{NTupleOfUnitRanges{N}}) where {N} = OffsetArrays.TupleOfRanges();

julia&gt; Base.convert(::Type{Tuple{Vararg{AbstractUnitRange{Int}}}}, t::NTupleOfUnitRanges) = t.x;

julia&gt; a = zeros(3, 3);

julia&gt; inds = NTupleOfUnitRanges((3:5, 2:4));

julia&gt; oa = OffsetArray(a, inds);

julia&gt; axes(oa, 1) == 3:5
true

julia&gt; axes(oa, 2) == 2:4
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/fe95c006c6052c083de3b01b70f1b049e5e09eed/src/utils.jl#L13-L53" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« For developers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 3 March 2021 14:11">Wednesday 3 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>