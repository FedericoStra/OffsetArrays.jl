var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"OffsetArray\nOffsetArrays.IdOffsetRange\nOffsetArrays.no_offset_view","category":"page"},{"location":"reference/#OffsetArrays.OffsetArray","page":"Reference","title":"OffsetArrays.OffsetArray","text":"OffsetArray(A, indices...)\n\nReturn an AbstractArray that shares element type and size with the first argument, but used the given indices, which are checked for compatible size.\n\nExample\n\njulia> A = OffsetArray(reshape(1:6, 2, 3), 0:1, -1:1)\n2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:\n 1  3  5\n 2  4  6\n\njulia> A[0, 1]\n5\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.IdOffsetRange","page":"Reference","title":"OffsetArrays.IdOffsetRange","text":"ro = IdOffsetRange(r::AbstractUnitRange, offset=0)\n\nConstruct an \"identity offset range\". Numerically, collect(ro) == collect(r) .+ offset, with the additional property that axes(ro, 1) = axes(r, 1) .+ offset. When r starts at 1, then ro[i] == i and even ro[ro] == ro, i.e., it's the \"identity,\" which is the origin of the \"Id\" in IdOffsetRange.\n\nExamples\n\nThe most common case is shifting a range that starts at 1 (either 1:n or Base.OneTo(n)):\n\njulia> ro = OffsetArrays.IdOffsetRange(1:3, -2)\n-1:1\n\njulia> axes(ro, 1)\n-1:1\n\njulia> ro[-1]\n-1\n\njulia> ro[3]\nERROR: BoundsError: attempt to access 3-element UnitRange{Int64} at index [5]\n\nIf the range doesn't start at 1, the values may be different from the indices:\n\njulia> ro = OffsetArrays.IdOffsetRange(11:13, -2)\n9:11\n\njulia> axes(ro, 1)     # 11:13 is indexed by 1:3, and the offset is also applied to the axes\n-1:1\n\njulia> ro[-1]\n9\n\njulia> ro[3]\nERROR: BoundsError: attempt to access 3-element UnitRange{Int64} at index [5]\n\nExtended help\n\nConstruction/coercion preserves the (shifted) values of the input range, but may modify the indexes if required by the specified types. For example,\n\nr = OffsetArrays.IdOffsetRange{Int,UnitRange{Int}}(3:4)\n\nhas r[1] == 3 and r[2] == 4, whereas\n\nr = OffsetArrays.IdOffsetRange{Int,Base.OneTo{Int}}(3:4)\n\nhas r[3] == 3 and r[4] == 4, and r[1] would throw a BoundsError. In this latter case, a shift in the axes was needed because Base.OneTo ranges must start with value 1.\n\nIn contrast, conversion preserves both the values and the indices, throwing an error when this is not achievable. For instance,\n\nr = convert(OffsetArrays.IdOffsetRange{Int,UnitRange{Int}}, 3:4)\n\nhas r[1] == 3 and r[2] == 4 and would satisfy r == 3:4, whereas\n\njulia> convert(OffsetArrays.IdOffsetRange{Int,Base.OneTo{Int}}, 3:4)\nERROR: ArgumentError: first element must be 1, got 3\n\nwhere the error arises because the result could not have the same axes as the input.\n\nAn important corollary is that typeof(r1)(r2) and oftype(r1, r2) behave differently: the first coerces r2 to be of the type of r1, whereas the second converts.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.no_offset_view","page":"Reference","title":"OffsetArrays.no_offset_view","text":"no_offset_view(A)\n\nReturn an AbstractArray that shares structure and has the same type and size as the argument, but has 1-based indexing. May just return the argument when applicable. Not exported.\n\nThe default implementation uses OffsetArrays, but other types should use something more specific to remove a level of indirection when applicable.\n\njulia> A = [1 3 5; 2 4 6];\n\njulia> O = OffsetArray(A, 0:1, -1:1)\n2×3 OffsetArray(::Array{Int64,2}, 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:\n 1  3  5\n 2  4  6\n\njulia> OffsetArrays.no_offset_view(O)[1,1] = -9\n-9\n\njulia> A\n2×3 Array{Int64,2}:\n -9  3  5\n  2  4  6\n\n\n\n\n\n","category":"function"},{"location":"#OffsetArrays.jl-1","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"","category":"section"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OffsetArrays provides Julia users with arrays that have arbitrary indices, similar to those found in some other programming languages like Fortran. Below is the basic usage found in the README, followed by a couple of short examples illustrating circumstances in which OffsetArrays can be useful. For a lengthier discussion, see this blog post.","category":"page"},{"location":"#Usage-1","page":"OffsetArrays.jl","title":"Usage","text":"","category":"section"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"You can construct such arrays as follows:","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OA = OffsetArray(A, axis1, axis2, ...)","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"where you want OA to have axes (axis1, axis2, ...) and be indexed by values that fall within these axis ranges. Example:","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"using OffsetArrays\nA = Float64.(reshape(1:15, 3, 5))\nprintln(\"Here is A:\")\ndisplay(A)\nOA = OffsetArray(A, -1:1, 0:4)    # OA will have axes (-1:1, 0:4)\nprintln(\"Here is OA:\")\ndisplay(OA)\n@show OA[-1,0] OA[1,4]","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"gives the output","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"here is A:\n3×5 Array{Float64,2}:\n 1.0  4.0  7.0  10.0  13.0\n 2.0  5.0  8.0  11.0  14.0\n 3.0  6.0  9.0  12.0  15.0\nhere is OA:\n3×5 OffsetArray(::Array{Float64,2}, -1:1, 0:4) with eltype Float64 with indices -1:1×0:4:\n 1.0  4.0  7.0  10.0  13.0\n 2.0  5.0  8.0  11.0  14.0\n 3.0  6.0  9.0  12.0  15.0\nOA[-1, 0] = 1.0\nOA[1, 4] = 15.0","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OffsetArrays works for arbitrary dimensionality:","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"julia> using OffsetArrays\n\njulia> y = OffsetArray{Float64}(undef, -1:1, -7:7, -128:512, -5:5, -1:1, -3:3, -2:2, -1:1);\n\njulia> summary(y)\n\"OffsetArrays.OffsetArray{Float64,8,Array{Float64,8}} with indices -1:1×-7:7×-128:512×-5:5×-1:1×-3:3×-2:2×-1:1\"\n\njulia> y[-1,-7,-128,-5,-1,-3,-2,-1] = 14\n14\n\njulia> y[-1,-7,-128,-5,-1,-3,-2,-1] += 5\n19.0","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"You can use OffsetArrays.no_offset_view(A) if you want to return a view of the data in A but where indexing starts at 1.","category":"page"},{"location":"#Example:-Relativistic-Notation-1","page":"OffsetArrays.jl","title":"Example: Relativistic Notation","text":"","category":"section"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Suppose we have a position vector r = [:x, :y, :z] which is naturally one-based, ie. r[1] == :x, r[2] == :y,  r[3] == :z and we also want to construct a relativistic position vector which includes time as the 0th component. This can be done with OffsetArrays like","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"julia> using OffsetArrays\n\njulia> r = [:x, :y, :z];\n\njulia> x = OffsetVector([:t, r...], 0:3)\n4-element OffsetArray(::Array{Symbol,1}, 0:3) with eltype Symbol with indices 0:3:\n :t\n :x\n :y\n :z\n\njulia> x[0]\n:t\n\njulia> x[1:3]\n3-element Array{Symbol,1}:\n :x\n :y\n :z","category":"page"},{"location":"#Example:-Polynomials-1","page":"OffsetArrays.jl","title":"Example: Polynomials","text":"","category":"section"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Suppose one wants to represent the Laurent polynomial","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"6/x + 5 - 2*x + 3*x^2 + x^3","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"in julia. The coefficients of this polynomial are a naturally -1 based list, since the nth element of the list (counting from -1) 6, 5, -2, 3, 1 is the coefficient corresponding to the nth power of x. This Laurent polynomial can be evaluated at say x = 2 as follows.","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"julia> using OffsetArrays\n\njulia> coeffs = OffsetVector([6, 5, -2, 3, 1], -1:3)\n5-element OffsetArray(::Array{Int64,1}, -1:3) with eltype Int64 with indices -1:3:\n  6\n  5\n -2\n  3\n  1\n\njulia> polynomial(x, coeffs) = sum(coeffs[n]*x^n for n in eachindex(coeffs))\npolynomial (generic function with 1 method)\n\njulia> polynomial(2.0, coeffs)\n24.0","category":"page"},{"location":"#","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Notice our use of the eachindex function which does not assume that the given array starts at 1.","category":"page"},{"location":"internals/#For-developers-1","page":"For developers","title":"For developers","text":"","category":"section"},{"location":"internals/#","page":"For developers","title":"For developers","text":"Writing code that supports OffsetArrays is generally fairly straightforward. The majority of cases can be handled with these tips:","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"replace many uses of size with axes\nreplace 1:length(A) with eachindex(A), or if you need an integer index with LinearIndices(A)\nreplace explicit allocations like Array{Int}(undef, size(B)) with similar(Array{Int}, axes(B))","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"More information can be found in Julia's developer documentation. The most subtle issues tend to arise around the axes, and further detail specific to OffsetArrays.jl follows below.","category":"page"},{"location":"internals/#Internals-1","page":"For developers","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"For developers","title":"For developers","text":"How does OffsetArrays work? The fundamental principle is very simple: an OffsetArray is just a wrapper around a \"parent\" array, together with an index offset:","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"julia> oa = OffsetArray([1 2; 3 4], 0:1, 5:6)\n2×2 OffsetArray(::Array{Int64,2}, 0:1, 5:6) with eltype Int64 with indices 0:1×5:6:\n 1  2\n 3  4\n\njulia> parent(oa)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> oa.offsets\n(-1, 4)","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"So parent(oa) is the original array we constructed it with, and oa.offsets is a tuple, each entry encoding the index-shift to be applied along the corresponding axis. When you index oa[i,j], it \"translates\" the i,j indexes back to the parent array's indexes and then returns the value in the parent.","category":"page"},{"location":"internals/#The-axes-of-OffsetArrays-1","page":"For developers","title":"The axes of OffsetArrays","text":"","category":"section"},{"location":"internals/#","page":"For developers","title":"For developers","text":"julia> axes(oa)\n(0:1, 5:6)","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"This looks straightforward, but if you dive deeper you'll notice some complexities:","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"julia> ax = axes(oa, 2)\n5:6\n\njulia> typeof(ax)\nOffsetArrays.IdOffsetRange{Int64,Base.OneTo{Int64}}\n\njulia> ax[1]\nERROR: BoundsError: attempt to access 2-element Base.OneTo{Int64} at index [-3]\nStacktrace:\n [1] throw_boundserror(::Base.OneTo{Int64}, ::Int64) at ./abstractarray.jl:538\n [2] getindex at ./range.jl:625 [inlined]\n [3] getindex(::OffsetArrays.IdOffsetRange{Int64,Base.OneTo{Int64}}, ::Int64) at /home/tim/.julia/dev/OffsetArrays/src/axes.jl:139\n [4] top-level scope at none:0\n\njulia> ax[5]\n5","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"The axes are of type OffsetArrays.IdOffsetRange. IdOffsetRanges are essentially OffsetArrays specialized for ranges, with the additional property that they tend to be their own axes:","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"julia> ax\n5:6\n\njulia> axes(ax)\n(5:6,)\n\njulia> axes(ax[ax])\n(5:6,)","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"This example of indexing is idempotent. This is a useful characteristic for ensuring the \"fundamental axiom\" of generalized indexing, that a[rng][i] == a[rng[i]]:","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"julia> oa2 = OffsetArray([5, 10, 15, 20], 0:3)\n4-element OffsetArray(::Array{Int64,1}, 0:3) with eltype Int64 with indices 0:3:\n  5\n 10\n 15\n 20\n\njulia> ax2 = axes(oa2, 1)\n0:3\n\njulia> oa2[2]\n15\n\njulia> oa2[ax2][2]\n15\n\njulia> oa2[ax2[2]]\n15","category":"page"},{"location":"internals/#","page":"For developers","title":"For developers","text":"IdOffsetRanges apply the offset both to the values and the indices of the range, and otherwise preserve the parent range.","category":"page"}]
}
